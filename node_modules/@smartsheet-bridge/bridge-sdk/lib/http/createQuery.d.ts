import { BridgeHTTPInstance, BridgeHTTPRequestConfig } from './types';
export interface BridgeHTTPQuery {
    fromRecord: number;
    maxRecords: number;
    orderBy: BridgeHTTPQueryOrder[];
    filters?: BridgeHTTPQueryFilter[];
    page: number;
}
export interface BridgeHTTPQueryOrder {
    field: string;
    ascending: boolean;
}
export interface BridgeHTTPQueryFilter {
    field: string;
    condition: BridgeHTTPFilterCondition;
    value: string[];
}
export declare const IS_EQUAL_TO = "IS_EQUAL_TO";
export declare const IS_NOT_EQUAL_TO = "IS_NOT_EQUAL_TO";
export declare const IS_GREATER_THAN = "IS_GREATER_THAN";
export declare const IS_LESS_THAN = "IS_LESS_THAN";
export declare const IS_GREATER_THAN_EQUAL = "IS_GREATER_THAN_EQUAL";
export declare const IS_LESS_THAN_EQUAL = "IS_LESS_THAN_EQUAL";
export declare const IS_IN = "IS_IN";
export declare const IS_NOT_IN = "IS_NOT_IN";
export declare type BridgeHTTPFilterCondition = typeof IS_EQUAL_TO | typeof IS_NOT_EQUAL_TO | typeof IS_GREATER_THAN | typeof IS_LESS_THAN | typeof IS_GREATER_THAN_EQUAL | typeof IS_LESS_THAN_EQUAL | typeof IS_IN | typeof IS_NOT_IN;
export interface BridgeHTTPQueryResponse<T = any> {
    info: {
        from: number;
        to: number;
        total: number;
    };
    data: T[];
}
declare const _default: <T = any, R = BridgeHTTPQueryResponse<T>>(resource: string) => {
    (instance: BridgeHTTPInstance): (options: BridgeHTTPQuery, config?: BridgeHTTPRequestConfig) => Promise<import("./types").BridgeHTTPResponse<R>>;
    (options: BridgeHTTPQuery, config: BridgeHTTPRequestConfig): Promise<import("./types").BridgeHTTPResponse<R>>;
};
export default _default;
//# sourceMappingURL=createQuery.d.ts.map