import { BridgeHTTPInstance, BridgeHTTPRequestConfig, BridgeHTTPResponse } from './http';
export interface AccountURL {
    accountName: string;
    hostName: string;
    protocol: string;
}
export declare const parseAccountURL: (accountURL: string) => AccountURL;
declare type HTTPFn = (data: {
    [key: string]: any;
}, config: BridgeHTTPRequestConfig) => Promise<BridgeHTTPResponse>;
declare type HTTPCall = (instance: BridgeHTTPInstance) => HTTPFn;
interface HTTPMap {
    [call: string]: HTTPCall;
}
export declare function createAPICall(fn: (instance: BridgeHTTPInstance) => (config: BridgeHTTPRequestConfig) => Promise<BridgeHTTPResponse>): {
    (instance: BridgeHTTPInstance): (config?: BridgeHTTPRequestConfig) => Promise<BridgeHTTPResponse>;
    (config: BridgeHTTPRequestConfig): Promise<BridgeHTTPResponse>;
};
export declare function createAPICall<Options extends {
    [key: string]: any;
}, R = any>(fn: (instance: BridgeHTTPInstance) => (options: Options, config: BridgeHTTPRequestConfig) => Promise<BridgeHTTPResponse<R>>): {
    (instance: BridgeHTTPInstance): (options: Options, config?: BridgeHTTPRequestConfig) => Promise<BridgeHTTPResponse<R>>;
    (options: Options, config: BridgeHTTPRequestConfig): Promise<BridgeHTTPResponse<R>>;
};
declare type APICallReturn<T> = T extends {
    (...args: any[]): infer R;
    (...args: any[]): any;
} ? R : T extends (...args: any[]) => infer R ? R : any;
declare type InferMap<T extends HTTPMap> = {
    [P in keyof T]: APICallReturn<T[P]>;
};
export declare const createAPIModule: <Fns extends HTTPMap, Return = InferMap<Fns>>(fns: Fns) => (instance: BridgeHTTPInstance) => Return;
export {};
//# sourceMappingURL=utils.d.ts.map